# SuperScreens - Documentação Técnica e Guia de Migração

Este documento serve como guia definitivo para desenvolvedores que estão assumindo o projeto "SuperScreens" para levá-lo do estágio de protótipo (Figma Make) para produção (Vercel + Supabase).

## 1. Visão Geral do Sistema

O **SuperScreens** é uma plataforma de Digital Signage (Sinalização Digital) composta por:
1.  **Admin Dashboard**: Gestão de clientes, playlists, anunciantes e relatórios financeiros/KPIs.
2.  **TV Player (PWA)**: Aplicação web que roda nas TVs, capaz de tocar offline, gerenciar cache, exibir anúncios programáticos e interagir com hardware (via APIs web).
3.  **Client Portal**: Área para anunciantes visualizarem seus próprios dados.
4.  **Remote Control**: Interface mobile acessada via QR Code na TV para controle remoto e Jukebox.

### Stack Tecnológica
-   **Frontend**: React (Vite), Tailwind CSS v4, Lucide Icons, Recharts, Framer Motion.
-   **Backend**: Supabase Edge Functions (Deno) rodando um servidor Hono.
-   **Database**: PostgreSQL (via Supabase), atualmente simulado via KV Store (JSON blobs).
-   **Realtime**: Supabase Realtime (Websockets) para controle remoto e atualização de status.

---

## 2. Estrutura de Arquivos e Diretórios

### `/pages` (Rotas da Aplicação)
*   **`/admin`**: Área administrativa protegida.
    *   `Dashboard.tsx`: KPIs, gráficos (Share of Voice), logs de sistema e status dos players.
    *   `Users.tsx`: CRUD de usuários (Clientes/Players) e ferramenta de "Sincronizar Base".
    *   `Advertisers.tsx`: Gestão de anunciantes legada (migrando para usuários).
    *   `AdDistribution.tsx`: Distribuição em massa de anúncios para múltiplos players.
    *   `RemoteControl.tsx`: Controle mestre administrativo.
*   **`/client`**: Área do cliente final (anunciante).
*   `TVPlayer.tsx`: **Core da aplicação**. O player que roda na TV. Gerencia loops de vídeo, injeção de anúncios, ticker de notícias e Jukebox.
*   `PlaylistBuilder.tsx`: Interface drag-and-drop para montar a programação.
*   `RequestRemote.tsx`: A interface que abre no celular do usuário ao escanear o QR Code.

### `/components`
*   `player/`: Componentes específicos da TV (MediaItem, AdPlayer, NewsTicker).
*   `ui/`: Componentes base (Shadcn UI) - Botões, Cards, Modais, Inputs.

### `/hooks`
*   `useTVPlayerLogic.ts`: **Arquivo Crítico**. Contém toda a lógica de estado do player, regras de negócio para inserção de anúncios, timer de slide, lógica de Jukebox e comunicação Realtime.

### `/supabase/functions/make-server-70a2af89`
*   `index.ts`: O Backend monolítico.
    *   Gerencia rotas de API (`/playlist`, `/users`, `/impression`).
    *   Contém a lógica de escrita no KV Store.
    *   **Nota**: Ao migrar, este arquivo deve ser refatorado ou quebrado em várias Edge Functions ou API Routes do Next.js.

---

## 3. Plano de Migração: De KV Store para SQL

Atualmente, o sistema usa uma única tabela `kv_store_70a2af89` armazenando JSONs gigantes. Para produção, isso deve ser migrado para tabelas relacionais para garantir integridade e performance.

### Passo 1: Modelagem do Banco (SQL Sugerido)

Execute estes comandos no SQL Editor do Supabase para criar a estrutura real:

```sql
-- 1. Tabela de Perfis (Estende auth.users)
CREATE TABLE public.profiles (
  id UUID REFERENCES auth.users(id) PRIMARY KEY,
  email TEXT,
  role TEXT CHECK (role IN ('admin', 'client', 'advertiser')),
  nome_fantasia TEXT,
  razao_social TEXT,
  logo_url TEXT,
  rss_url TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- 2. Tabela de Mídias (Acervo)
CREATE TABLE public.media_items (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  owner_id UUID REFERENCES public.profiles(id),
  title TEXT,
  url TEXT NOT NULL,
  type TEXT CHECK (type IN ('video', 'image', 'youtube')),
  duration INTEGER DEFAULT 15,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- 3. Tabela de Anúncios (Campanhas)
CREATE TABLE public.ads (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  advertiser_id UUID REFERENCES public.profiles(id), -- Quem paga
  media_item_id UUID REFERENCES public.media_items(id), -- O arquivo
  layout TEXT DEFAULT 'fullscreen',
  active BOOLEAN DEFAULT true,
  impressions_count BIGINT DEFAULT 0
);

-- 4. Tabela de Playlists
CREATE TABLE public.playlists (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  owner_id UUID REFERENCES public.profiles(id),
  name TEXT,
  items JSONB, -- Array de IDs de media_items
  settings JSONB -- { shuffle: boolean, etc }
);

-- 5. Logs de Atividade (Para Share of Voice)
CREATE TABLE public.activity_logs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  advertiser_id UUID REFERENCES public.profiles(id), -- Opcional
  type TEXT CHECK (type IN ('ad', 'media', 'tv', 'jukebox')),
  message TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);
```

### Passo 2: Migração de Dados (ETL)

Você precisará criar um script (pode ser em Node.js ou uma Edge Function temporária) que:
1.  Lê o JSON `users_list` do KV e insere em `public.profiles`.
2.  Lê o JSON `advertisers` do KV e insere em `public.ads`.
3.  Lê o JSON `activity_log` e insere histórico em `public.activity_logs`.

### Passo 3: Refatoração do Backend

No arquivo `/supabase/functions/make-server-70a2af89/index.ts`, substitua as chamadas `kv.get` pelo Supabase Client.

**Antes (KV):**
```typescript
const users = await kv.get("users_list");
const user = users.find(u => u.id === targetId);
```

**Depois (SQL):**
```typescript
const { data: user, error } = await supabase
  .from('profiles')
  .select('*')
  .eq('id', targetId)
  .single();
```

---

## 4. Notas Importantes para o Desenvolvedor (Setup Local)

### 1. Importação de Imagens (`figma:asset`)
O código atual usa imports virtuais do Figma (`import img from "figma:asset/..."`).
**Ação Necessária**:
*   Baixe todas as imagens usadas.
*   Coloque-as na pasta `/public` ou `/src/assets`.
*   Substitua os imports no código: `import img from "/assets/logo.png"`.

### 2. Rotas da API
O frontend faz chamadas para `${supabaseUrl}/functions/v1/make-server...`.
**Ação Necessária**:
*   Se for usar **Vercel**, considere migrar as funções do `index.tsx` para **API Routes** (`/api/...`) se for mudar para Next.js, ou mantenha as Edge Functions no Supabase e apenas atualize a variável de ambiente `VITE_API_URL` no frontend.

### 3. Autenticação
O projeto usa `supbase-js`. Certifique-se de configurar as variáveis de ambiente no seu `.env.local`:
```env
VITE_SUPABASE_URL=sua_url
VITE_SUPABASE_ANON_KEY=sua_chave_anonima
```

### 4. Tailwind CSS v4
Este projeto usa a versão mais recente do Tailwind. Não há `tailwind.config.js` tradicional; a configuração fica no CSS principal (`globals.css`). Fique atento a essa diferença se estiver acostumado com a v3.

### 5. Lógica de "Share of Voice"
A correção recente garantiu que o Backend tente descobrir o nome do anunciante baseado no ID do anúncio (`ad-ID_ANUNCIANTE-...`) caso o frontend falhe em enviar. Ao refatorar para SQL, lembre-se de manter essa lógica de "join" no momento de registrar o log na tabela `activity_logs`.

---

**Sucesso no projeto!** A base arquitetural do frontend está sólida e o PWA é funcional. O trabalho principal agora é fortalecer o Backend (persistência de dados).
